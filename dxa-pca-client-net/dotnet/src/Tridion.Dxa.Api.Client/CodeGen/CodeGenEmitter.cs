using System;
using System.Collections.Generic;
using System.Text;
using Tridion.Dxa.Api.Client.GraphQLClient.Schema;
using Tridion.Dxa.Api.Client.Utils;

namespace Tridion.Dxa.Api.Client.CodeGen
{
    /// <summary>
    /// Emits code for generating classes/query builders from a graphQL schema
    /// </summary>
    internal static class CodeGenEmitter
    {       
        static string Indent(int level) => new string('\t', level);

        static void EmitNewLine(StringBuilder sb)
            => Emit(sb, string.Empty, true);

        static void Emit(StringBuilder sb, string text)
            => Emit(sb, text, 0, false);

        static void Emit(StringBuilder sb, string text, bool appendLine)
            => Emit(sb, text, 0, appendLine);

        static void Emit(StringBuilder sb, string text, int indentLevel)
            => Emit(sb, text, indentLevel, false);

        static void Emit(StringBuilder sb, string text, int indentLevel, bool appendLine)
        {
            if (appendLine)
                sb.AppendLine($"{Indent(indentLevel)}{text}");
            else
                sb.Append($"{Indent(indentLevel)}{text}");
        }

        static string EmitHeader(string ns)
        {
            var sb = new StringBuilder();
            Emit(sb, $"// This file was generated by a tool on {DateTime.Now}", true);
            Emit(sb, "using System;", true);
            Emit(sb, "using System.Collections;", true);
            Emit(sb, "using System.Collections.Generic;", true);
            Emit(sb, "using Newtonsoft.Json;", true);
            Emit(sb, "using Newtonsoft.Json.Converters;", true);
            Emit(sb, "using Tridion.Dxa.Api.Client.QueryBuilder;", true);
            Emit(sb, "using Tridion.Dxa.Api.Client.GraphQLClient;", true);
            Emit(sb, "using Tridion.Dxa.Api.Client.CodeGen;", true);
            Emit(sb, $"namespace {ns}", true);
            return sb.ToString();
        }

        static void EmitComment(StringBuilder sb, string comment, int indentLevel)
        {
            if (string.IsNullOrEmpty(comment)) return;
            Emit(sb, "/// <summary>", indentLevel, true);
            Emit(sb, $"/// {comment}", indentLevel, true);
            Emit(sb, "/// </summary>", indentLevel, true);
        }

        static void EmitFields(StringBuilder sb, List<GraphQLSchemaField> fields, int indentLevel, bool isPublic, bool serialize)
        {
            if (fields == null) return;
            foreach (var field in fields)
            {
                EmitNewLine(sb);
                EmitComment(sb, field.Description, indentLevel);
                if(serialize) Emit(sb, "[GraphQLField]", indentLevel, true);
                Emit(sb, $"{(isPublic ? "public " : "")}{field.Type.TypeName()} {field.Name.PascalCase()} {{ get; set; }}", indentLevel, true);
            }
        }

        static void EmitFields(StringBuilder sb, List<GraphQLSchemaEnum> enumValues, int indentLevel)
        {
            if (enumValues == null) return;
            var firstAdded = false;
            foreach (var value in enumValues)
            {
                if(firstAdded) Emit(sb, ",");
                EmitNewLine(sb);
                EmitComment(sb, value.Description, indentLevel);
                Emit(sb, $"{value.Name.PascalCase()}", indentLevel);
                firstAdded = true;
            }
            EmitNewLine(sb);
        }

        static CodeGenInfo EmitClass(GraphQLSchema schema, GraphQLSchemaType type, int indentLevel)
        {
            if (type.Name.StartsWith("__")) return null;
            if (type.Kind == "SCALAR") return null;
            var info = new CodeGenInfo
            {
                Typename = type.TypeName()
            };

            var sb = new StringBuilder();
            EmitComment(sb, type.Description, indentLevel);
            Emit(sb, $"public {type.EmitTypeDecl()}", indentLevel);
            if (type.Interfaces != null && type.Interfaces.Count > 0)
            {
                Emit(sb, " : ");
                for (var i = 0; i <= type.Interfaces.Count - 2; i++)
                {
                    Emit(sb, $"{type.Interfaces[i].TypeName()}, ");
                }
                sb.Append($"{type.Interfaces[type.Interfaces.Count - 1].TypeName()}");
            }
            EmitNewLine(sb);
            Emit(sb, "{", indentLevel);
            switch (type.Kind)
            {
                case "OBJECT":
                    EmitFields(sb, type.Fields, indentLevel + 1, true, false);
                    break;
                case "INPUT_OBJECT":
                    EmitFields(sb, type.InputFields, indentLevel + 1, true, true);
                    break;
                case "INTERFACE":
                    if (type.PossibleTypes != null)
                    {
                        EmitFields(sb, type.Fields, indentLevel + 1, false, false);
                    }
                    break;
                case "ENUM":
                    EmitFields(sb, type.EnumValues, indentLevel + 1);
                    break;
                default:
                    Emit(sb, "/* oops - something went wrong generating code */");
                    break;
            }
            Emit(sb, "}", indentLevel, true);
            info.Content = sb.ToString();
            return info;
        }

        public static List<CodeGenInfo> GenerateTypes(GraphQLSchema schema, string ns)
        {
            var types = new List<CodeGenInfo>();
            foreach (var type in schema.Types)
            {
                var info = EmitClass(schema, type, 1);
                if (info == null) continue;
                var sb = new StringBuilder();
                Emit(sb, $"// This file was generated by a tool on {DateTime.Now}", true);
                Emit(sb, "using System;", true);
                Emit(sb, "using System.Collections;", true);
                Emit(sb, "using System.Collections.Generic;", true);
                Emit(sb, "using Newtonsoft.Json;", true);
                Emit(sb, "using Newtonsoft.Json.Converters;", true);
                Emit(sb, "using Tridion.Dxa.Api.Client.QueryBuilder;", true);
                Emit(sb, "using Tridion.Dxa.Api.Client.GraphQLClient;", true);
                Emit(sb, "using Tridion.Dxa.Api.Client.CodeGen;", true);
                Emit(sb, $"namespace {ns}", true);
                info.Header = sb.ToString();
                types.Add(info);
            }

            return types;
        }

        static string EmitArgsList(List<GraphQLSchemaFieldArgs> args)
        {
            var sb = new StringBuilder();
            if (args == null || args.Count == 0) return "()";           
            Emit(sb, "(");
            var firstAdded = false;
            foreach (var arg in args)
            {
                if (firstAdded) Emit(sb, ", ");
                Emit(sb, $"{arg.Type.TypeName()} {arg.Name}");
                firstAdded = true;
            }
            Emit(sb, ")");
            return sb.ToString();
        }

        static string EmitArgsDef(List<GraphQLSchemaFieldArgs> args, int indentLevel)
        {
            StringBuilder sb = new StringBuilder();
            Emit(sb, "var args = new QueryArguments{", 0, true);
            var firstAdded = false;
            foreach (var arg in args)
            {
                if(firstAdded) Emit(sb, ", ", true);
                Emit(sb, $"{{\"{arg.Name}\", {arg.Name}}}", indentLevel + 2, false);
                firstAdded = true;
            }
            Emit(sb, "};", true);
            return sb.ToString();
        }

        static void EmitQueryBuilderMethod(StringBuilder sb, string returnType, GraphQLSchemaField field,
            int indentLevel)
        {
            if (field.IsObjectType() || field.IsInterfaceType())
            {
                returnType = $"{field.GetFieldTypeName().PascalCase()}QueryBuilder";
            }

            Emit(sb, $"public {returnType} With{field.Name.PascalCase()}{EmitArgsList(field.Args)}", indentLevel, true);
          
            if (field.Args != null && field.Args.Count > 0)
            {
                Emit(sb, "{", indentLevel, true);
                Emit(sb, EmitArgsDef(field.Args, indentLevel), indentLevel + 1, true);
                Emit(sb, $"return ({returnType})Add(\"{field.Name}\", args, new {returnType}());", indentLevel + 1, true);
                Emit(sb, "}", indentLevel, true);
                return;
            }

            if (field.IsObjectType() || field.IsInterfaceType())
            {
                Emit(sb, $"=> ({returnType})Add(\"{field.Name}\", null, new {returnType}());", indentLevel + 1, true);
            }
            else
            {
                Emit(sb, $"=> ({returnType})Add(\"{field.Name}\");", indentLevel + 1, true);
            }
        }

        static CodeGenInfo EmitQueryBuilder(GraphQLSchemaType schemaType, int indentLevel)
        {
            var sb = new StringBuilder();
            var queryBuilderName = $"{schemaType.Name.PascalCase()}QueryBuilder";
            var info = new CodeGenInfo {Typename = queryBuilderName};
            Emit(sb, $"public class {queryBuilderName} : QueryBuilder", indentLevel, true);
            Emit(sb, "{", indentLevel, true);
            Emit(sb, $"public {queryBuilderName}() {{}}", indentLevel + 1, true);
            Emit(sb, $"public {queryBuilderName}(string queryName) : base(queryName) {{}}", indentLevel + 1, true);
            Emit(sb, $"public {queryBuilderName}(string queryName, QueryArguments arguments) : base(queryName, arguments) {{}}", indentLevel + 1, true);
            Emit(sb, $"public {queryBuilderName} WithAllFields()", indentLevel + 1, true);
            Emit(sb, "{", indentLevel + 1, true);
            foreach (var field in schemaType.Fields)
            {
                if (field.HasArguments()) continue;
                if (field.IsObjectType() || field.IsInterfaceType())
                {
                    Emit(sb, $"var {field.Name} = With{field.Name.PascalCase()}();", indentLevel + 2, true);
                    Emit(sb, $"{field.Name}.WithAllFields();", indentLevel + 2, true);
                }
                else
                {
                    Emit(sb, $"With{field.Name.PascalCase()}();", indentLevel + 2, true);
                }                
            }
            Emit(sb, "return this;", indentLevel + 2, true);
            Emit(sb, "}", indentLevel + 1, true);
            foreach (var field in schemaType.Fields)
            {
                EmitQueryBuilderMethod(sb, queryBuilderName, field, indentLevel + 1);
            }

            if (schemaType.IsInterfaceType())
            {
                foreach (var possibleTypes in schemaType.ConcreteTypes())
                {
                    var t = $"{possibleTypes.GetFieldTypeName()}";
                    Emit(sb, $"public {t}QueryBuilder With{t}()=> ({t}QueryBuilder)Add(new {t}QueryBuilder());",
                        indentLevel + 1, true);
                }
            }

            Emit(sb, "}", indentLevel, true);
            info.Content = sb.ToString();
            return info;
        }

        static CodeGenInfo EmitRootQuery(GraphQLSchemaType rootQuery, Dictionary<string, List<string>> typesToRegister, int indentLevel)
        {
            var sb = new StringBuilder();
            var name = rootQuery.Name.PascalCase();
            var info = new CodeGenInfo {Typename = $"{name}RootQuery"};
            EmitComment(sb, rootQuery.Description, indentLevel);
            Emit(sb, $"public partial class {name}", indentLevel, true);
            Emit(sb, "{", indentLevel, true);
            Emit(sb, "private readonly IGraphQLClient _client;", indentLevel + 1, true);
            Emit(sb, $"public {name}(IGraphQLClient client)", indentLevel + 1, true);
            Emit(sb, "{", indentLevel + 1, true);
            Emit(sb, "_client = client;", indentLevel + 2, true);
            Emit(sb, "}", indentLevel + 1, true);
            Emit(sb, $"public static {name} Create(IGraphQLClient client)", indentLevel + 1, true);
            Emit(sb, "{", indentLevel + 1, true);
            Emit(sb, "if(client == null) throw new ArgumentNullException(\"GraphQL client not provided\");", indentLevel + 2, true);
            HashSet<string> registerd = new HashSet<string>();
            foreach(var type in typesToRegister)
            {
                foreach (var impl in type.Value)
                {
                    if (registerd.Contains(impl)) continue;
                    registerd.Add(impl);
                    Emit(sb, $"client.RegisterType(typeof({impl}));", indentLevel + 2, true);
                }
                Emit(sb, $"client.Converters.Add(new ItemConverter<{type.Key}>(client));", indentLevel + 2, true);
            }
            Emit(sb, $"return new {name}(client);", indentLevel + 2, true);
            Emit(sb, "}", indentLevel + 1, true);
            EmitNewLine(sb);

            var getMethodsAdded = new Dictionary<string, List<string>>();
           
            foreach (var field in rootQuery.Fields)
            {
                var methodName = field.Name.PascalCase();
                string typeName = "UnknownType";
                string typeDecl = field.EmitTypeDecl();
                if (field.Type.Kind == "OBJECT")
                    typeName = field.Type.Name;
                if (field.Type.Kind == "LIST")
                    typeName = field.Type.OfType.Name;
                var args = EmitArgsList(field.Args);               
                var queryName = $"{field.Name}";
                var queryBuilderName = $"{typeName}QueryBuilder";               

                Emit(sb, $"public {queryBuilderName} Create{methodName}QueryBuilder{args}", indentLevel + 1, true);
                Emit(sb, "{", indentLevel + 1, true);
                Emit(sb, $"{EmitArgsDef(field.Args, indentLevel + 2)}", indentLevel + 2, true);
                Emit(sb, $"return new {queryBuilderName}(\"{queryName}\", args);", indentLevel + 2, true);
                Emit(sb, "}", indentLevel + 1, true);
                EmitNewLine(sb);
                var getMethodName = field.Type.Kind == "LIST" ? "GetQueryResultList" : "GetQueryResult";
                var getMethod = $"{getMethodName}({queryBuilderName} builder)";
                var methodSigniture = $"public {typeDecl} {getMethod}";

                if (!getMethodsAdded.ContainsKey(methodSigniture))
                {
                    getMethodsAdded.Add(methodSigniture, new List<string> { queryName });
                }
                else
                {
                    getMethodsAdded[methodSigniture].Add(queryName);
                }
            }
            foreach(var x in getMethodsAdded)
            {
                Emit(sb, $"{x.Key}", indentLevel + 1, true);
                if (x.Value.Count > 1)
                {
                    Emit(sb, "{", indentLevel + 1, true);
                    Emit(sb, "var query = \"{\" + builder.Build() + \"}\";", indentLevel + 2, true);
                    Emit(sb, "switch(builder.QueryName)", indentLevel + 2, true);
                    Emit(sb, "{", indentLevel + 2, true);
                    foreach (var q in x.Value)
                    {
                        Emit(sb, $"case \"{q}\":", indentLevel + 3, true);
                        Emit(sb, $"return _client.Execute<{name}>(query).{q.PascalCase()};", indentLevel + 4, true);
                    }
                    Emit(sb, "}", indentLevel + 2, true);
                    Emit(sb, "return null;", indentLevel + 2, true);
                    Emit(sb, "}", indentLevel + 1, true);
                }
                else
                {
                    Emit(sb, $"=> _client.Execute<{name}>(\"{{\" + builder.Build() + \"}}\").{x.Value[0].PascalCase()};", indentLevel + 2, true);
                }               
            }

            Emit(sb, "}", indentLevel, true);
            info.Content = sb.ToString();
            return info;
        }

        public static List<CodeGenInfo> GenerateQueryBuilders(GraphQLSchema schema, string ns)
        {
            var results = new List<CodeGenInfo>();
            
            Dictionary<string, GraphQLSchemaType> types = new Dictionary<string, GraphQLSchemaType>();
            GraphQLSchemaType rootQuery = null;
            var typesToRegister = new Dictionary<string, List<string>>();

            
            foreach (var type in schema.Types)
            {
                if (type.Name.StartsWith("__")) continue;
                if (type.Kind == "SCALAR") continue;
                if (type.Kind == "ENUM") continue;
                if (type.Kind == "INPUT_OBJECT") continue;
                if (type.Kind == "LIST") continue;
                if (schema.QueryType.Name == type.Name)
                {
                    rootQuery = type;
                    continue;
                }

                if (type.IsInterfaceType())
                {
                    var impls = new List<string>();
                    foreach (var impl in type.ConcreteTypes())
                    {
                        impls.Add(impl.Name);
                    }
                    typesToRegister.Add($"I{type.Name}", impls);
                }
                types.Add(type.Name, type);
            }

            if (rootQuery != null)
            {
                var info = EmitRootQuery(rootQuery, typesToRegister, 1);
                if (info != null)
                {
                    var sb = new StringBuilder();
                    Emit(sb, $"// This file was generated by a tool on {DateTime.Now}", true);
                    Emit(sb, "using System;", true);
                    Emit(sb, "using System.Collections;", true);
                    Emit(sb, "using System.Collections.Generic;", true);
                    Emit(sb, "using Newtonsoft.Json;", true);
                    Emit(sb, "using Newtonsoft.Json.Converters;", true);
                    Emit(sb, "using Tridion.Dxa.Api.Client.QueryBuilder;", true);
                    Emit(sb, "using Tridion.Dxa.Api.Client.GraphQLClient;", true);
                    Emit(sb, "using Tridion.Dxa.Api.Client.CodeGen;", true);
                    Emit(sb, $"namespace {ns}", true);
                    info.Header = sb.ToString();
                    results.Add(info);
                }               
            }

            foreach (var type in types)
            {
                var info = EmitQueryBuilder(type.Value, 1);
                if (info == null) continue;
                var sb = new StringBuilder();
                Emit(sb, $"// This file was generated by a tool on {DateTime.Now}", true);
                Emit(sb, "using System;", true);
                Emit(sb, "using System.Collections;", true);
                Emit(sb, "using System.Collections.Generic;", true);
                Emit(sb, "using Newtonsoft.Json;", true);
                Emit(sb, "using Newtonsoft.Json.Converters;", true);
                Emit(sb, "using Tridion.Dxa.Api.Client.QueryBuilder;", true);
                Emit(sb, "using Tridion.Dxa.Api.Client.GraphQLClient;", true);
                Emit(sb, "using Tridion.Dxa.Api.Client.CodeGen;", true);
                Emit(sb, $"namespace {ns}", true);
                info.Header = sb.ToString();
                results.Add(info);
            }

            return results;
        }
    }
}
